// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package oci

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// This resource provides the Sign resource in Oracle Cloud Infrastructure Kms service.
//
// Creates a digital signature for a message or message digest by using the private key of a public-private key pair,
// also known as an asymmetric key. To verify the generated signature, you can use the [Verify](https://docs.cloud.oracle.com/iaas/api/#/en/key/latest/VerifiedData/Verify)
// operation. Or, if you want to validate the signature outside of the service, you can do so by using the public key of the same asymmetric key.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-oci/sdk/go/oci"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		_, err := oci.NewKmsSign(ctx, "testSign", &oci.KmsSignArgs{
// 			CryptoEndpoint:   pulumi.Any(_var.Sign_message_crypto_endpoint),
// 			KeyId:            pulumi.Any(oci_kms_key.Test_key.Id),
// 			Message:          pulumi.Any(_var.Sign_message),
// 			SigningAlgorithm: pulumi.Any(_var.Sign_signing_algorithm),
// 			KeyVersionId:     pulumi.Any(oci_kms_key_version.Test_key_version.Id),
// 			MessageType:      pulumi.Any(_var.Sign_message_type),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
//
// ## Import
//
// Sign can be imported using the `id`, e.g.
//
// ```sh
//  $ pulumi import oci:index/kmsSign:KmsSign test_sign "id"
// ```
type KmsSign struct {
	pulumi.CustomResourceState

	// The service endpoint to perform cryptographic operations against. Cryptographic operations include 'Encrypt,' 'Decrypt,', 'GenerateDataEncryptionKey', 'Sign' and 'Verify' operations. see Vault Crypto endpoint.
	CryptoEndpoint pulumi.StringOutput `pulumi:"cryptoEndpoint"`
	// The OCID of the key used to sign the message.
	KeyId pulumi.StringOutput `pulumi:"keyId"`
	// The OCID of the key version used to sign the message.
	KeyVersionId pulumi.StringOutput `pulumi:"keyVersionId"`
	// The base64-encoded binary data object denoting the message or message digest to sign. You can have a message up to 4096 bytes in size. To sign a larger message, provide the message digest.
	Message pulumi.StringOutput `pulumi:"message"`
	// Denotes whether the value of the message parameter is a raw message or a message digest.  The default value, `RAW`, indicates a message. To indicate a message digest, use `DIGEST`.
	MessageType pulumi.StringOutput `pulumi:"messageType"`
	// The base64-encoded binary data object denoting the cryptographic signature generated for the message or message digest.
	Signature pulumi.StringOutput `pulumi:"signature"`
	// The algorithm to use to sign the message or message digest. For RSA keys, supported signature schemes include PKCS #1 and RSASSA-PSS, along with  different hashing algorithms.  For ECDSA keys, ECDSA is the supported signature scheme with different hashing algorithms. When you pass a message digest for signing, ensure that you specify the same hashing algorithm  as used when creating the message digest.
	SigningAlgorithm pulumi.StringOutput `pulumi:"signingAlgorithm"`
}

// NewKmsSign registers a new resource with the given unique name, arguments, and options.
func NewKmsSign(ctx *pulumi.Context,
	name string, args *KmsSignArgs, opts ...pulumi.ResourceOption) (*KmsSign, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.CryptoEndpoint == nil {
		return nil, errors.New("invalid value for required argument 'CryptoEndpoint'")
	}
	if args.KeyId == nil {
		return nil, errors.New("invalid value for required argument 'KeyId'")
	}
	if args.Message == nil {
		return nil, errors.New("invalid value for required argument 'Message'")
	}
	if args.SigningAlgorithm == nil {
		return nil, errors.New("invalid value for required argument 'SigningAlgorithm'")
	}
	var resource KmsSign
	err := ctx.RegisterResource("oci:index/kmsSign:KmsSign", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetKmsSign gets an existing KmsSign resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetKmsSign(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *KmsSignState, opts ...pulumi.ResourceOption) (*KmsSign, error) {
	var resource KmsSign
	err := ctx.ReadResource("oci:index/kmsSign:KmsSign", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering KmsSign resources.
type kmsSignState struct {
	// The service endpoint to perform cryptographic operations against. Cryptographic operations include 'Encrypt,' 'Decrypt,', 'GenerateDataEncryptionKey', 'Sign' and 'Verify' operations. see Vault Crypto endpoint.
	CryptoEndpoint *string `pulumi:"cryptoEndpoint"`
	// The OCID of the key used to sign the message.
	KeyId *string `pulumi:"keyId"`
	// The OCID of the key version used to sign the message.
	KeyVersionId *string `pulumi:"keyVersionId"`
	// The base64-encoded binary data object denoting the message or message digest to sign. You can have a message up to 4096 bytes in size. To sign a larger message, provide the message digest.
	Message *string `pulumi:"message"`
	// Denotes whether the value of the message parameter is a raw message or a message digest.  The default value, `RAW`, indicates a message. To indicate a message digest, use `DIGEST`.
	MessageType *string `pulumi:"messageType"`
	// The base64-encoded binary data object denoting the cryptographic signature generated for the message or message digest.
	Signature *string `pulumi:"signature"`
	// The algorithm to use to sign the message or message digest. For RSA keys, supported signature schemes include PKCS #1 and RSASSA-PSS, along with  different hashing algorithms.  For ECDSA keys, ECDSA is the supported signature scheme with different hashing algorithms. When you pass a message digest for signing, ensure that you specify the same hashing algorithm  as used when creating the message digest.
	SigningAlgorithm *string `pulumi:"signingAlgorithm"`
}

type KmsSignState struct {
	// The service endpoint to perform cryptographic operations against. Cryptographic operations include 'Encrypt,' 'Decrypt,', 'GenerateDataEncryptionKey', 'Sign' and 'Verify' operations. see Vault Crypto endpoint.
	CryptoEndpoint pulumi.StringPtrInput
	// The OCID of the key used to sign the message.
	KeyId pulumi.StringPtrInput
	// The OCID of the key version used to sign the message.
	KeyVersionId pulumi.StringPtrInput
	// The base64-encoded binary data object denoting the message or message digest to sign. You can have a message up to 4096 bytes in size. To sign a larger message, provide the message digest.
	Message pulumi.StringPtrInput
	// Denotes whether the value of the message parameter is a raw message or a message digest.  The default value, `RAW`, indicates a message. To indicate a message digest, use `DIGEST`.
	MessageType pulumi.StringPtrInput
	// The base64-encoded binary data object denoting the cryptographic signature generated for the message or message digest.
	Signature pulumi.StringPtrInput
	// The algorithm to use to sign the message or message digest. For RSA keys, supported signature schemes include PKCS #1 and RSASSA-PSS, along with  different hashing algorithms.  For ECDSA keys, ECDSA is the supported signature scheme with different hashing algorithms. When you pass a message digest for signing, ensure that you specify the same hashing algorithm  as used when creating the message digest.
	SigningAlgorithm pulumi.StringPtrInput
}

func (KmsSignState) ElementType() reflect.Type {
	return reflect.TypeOf((*kmsSignState)(nil)).Elem()
}

type kmsSignArgs struct {
	// The service endpoint to perform cryptographic operations against. Cryptographic operations include 'Encrypt,' 'Decrypt,', 'GenerateDataEncryptionKey', 'Sign' and 'Verify' operations. see Vault Crypto endpoint.
	CryptoEndpoint string `pulumi:"cryptoEndpoint"`
	// The OCID of the key used to sign the message.
	KeyId string `pulumi:"keyId"`
	// The OCID of the key version used to sign the message.
	KeyVersionId *string `pulumi:"keyVersionId"`
	// The base64-encoded binary data object denoting the message or message digest to sign. You can have a message up to 4096 bytes in size. To sign a larger message, provide the message digest.
	Message string `pulumi:"message"`
	// Denotes whether the value of the message parameter is a raw message or a message digest.  The default value, `RAW`, indicates a message. To indicate a message digest, use `DIGEST`.
	MessageType *string `pulumi:"messageType"`
	// The algorithm to use to sign the message or message digest. For RSA keys, supported signature schemes include PKCS #1 and RSASSA-PSS, along with  different hashing algorithms.  For ECDSA keys, ECDSA is the supported signature scheme with different hashing algorithms. When you pass a message digest for signing, ensure that you specify the same hashing algorithm  as used when creating the message digest.
	SigningAlgorithm string `pulumi:"signingAlgorithm"`
}

// The set of arguments for constructing a KmsSign resource.
type KmsSignArgs struct {
	// The service endpoint to perform cryptographic operations against. Cryptographic operations include 'Encrypt,' 'Decrypt,', 'GenerateDataEncryptionKey', 'Sign' and 'Verify' operations. see Vault Crypto endpoint.
	CryptoEndpoint pulumi.StringInput
	// The OCID of the key used to sign the message.
	KeyId pulumi.StringInput
	// The OCID of the key version used to sign the message.
	KeyVersionId pulumi.StringPtrInput
	// The base64-encoded binary data object denoting the message or message digest to sign. You can have a message up to 4096 bytes in size. To sign a larger message, provide the message digest.
	Message pulumi.StringInput
	// Denotes whether the value of the message parameter is a raw message or a message digest.  The default value, `RAW`, indicates a message. To indicate a message digest, use `DIGEST`.
	MessageType pulumi.StringPtrInput
	// The algorithm to use to sign the message or message digest. For RSA keys, supported signature schemes include PKCS #1 and RSASSA-PSS, along with  different hashing algorithms.  For ECDSA keys, ECDSA is the supported signature scheme with different hashing algorithms. When you pass a message digest for signing, ensure that you specify the same hashing algorithm  as used when creating the message digest.
	SigningAlgorithm pulumi.StringInput
}

func (KmsSignArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*kmsSignArgs)(nil)).Elem()
}

type KmsSignInput interface {
	pulumi.Input

	ToKmsSignOutput() KmsSignOutput
	ToKmsSignOutputWithContext(ctx context.Context) KmsSignOutput
}

func (*KmsSign) ElementType() reflect.Type {
	return reflect.TypeOf((*KmsSign)(nil))
}

func (i *KmsSign) ToKmsSignOutput() KmsSignOutput {
	return i.ToKmsSignOutputWithContext(context.Background())
}

func (i *KmsSign) ToKmsSignOutputWithContext(ctx context.Context) KmsSignOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KmsSignOutput)
}

func (i *KmsSign) ToKmsSignPtrOutput() KmsSignPtrOutput {
	return i.ToKmsSignPtrOutputWithContext(context.Background())
}

func (i *KmsSign) ToKmsSignPtrOutputWithContext(ctx context.Context) KmsSignPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KmsSignPtrOutput)
}

type KmsSignPtrInput interface {
	pulumi.Input

	ToKmsSignPtrOutput() KmsSignPtrOutput
	ToKmsSignPtrOutputWithContext(ctx context.Context) KmsSignPtrOutput
}

type kmsSignPtrType KmsSignArgs

func (*kmsSignPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**KmsSign)(nil))
}

func (i *kmsSignPtrType) ToKmsSignPtrOutput() KmsSignPtrOutput {
	return i.ToKmsSignPtrOutputWithContext(context.Background())
}

func (i *kmsSignPtrType) ToKmsSignPtrOutputWithContext(ctx context.Context) KmsSignPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KmsSignPtrOutput)
}

// KmsSignArrayInput is an input type that accepts KmsSignArray and KmsSignArrayOutput values.
// You can construct a concrete instance of `KmsSignArrayInput` via:
//
//          KmsSignArray{ KmsSignArgs{...} }
type KmsSignArrayInput interface {
	pulumi.Input

	ToKmsSignArrayOutput() KmsSignArrayOutput
	ToKmsSignArrayOutputWithContext(context.Context) KmsSignArrayOutput
}

type KmsSignArray []KmsSignInput

func (KmsSignArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*KmsSign)(nil)).Elem()
}

func (i KmsSignArray) ToKmsSignArrayOutput() KmsSignArrayOutput {
	return i.ToKmsSignArrayOutputWithContext(context.Background())
}

func (i KmsSignArray) ToKmsSignArrayOutputWithContext(ctx context.Context) KmsSignArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KmsSignArrayOutput)
}

// KmsSignMapInput is an input type that accepts KmsSignMap and KmsSignMapOutput values.
// You can construct a concrete instance of `KmsSignMapInput` via:
//
//          KmsSignMap{ "key": KmsSignArgs{...} }
type KmsSignMapInput interface {
	pulumi.Input

	ToKmsSignMapOutput() KmsSignMapOutput
	ToKmsSignMapOutputWithContext(context.Context) KmsSignMapOutput
}

type KmsSignMap map[string]KmsSignInput

func (KmsSignMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*KmsSign)(nil)).Elem()
}

func (i KmsSignMap) ToKmsSignMapOutput() KmsSignMapOutput {
	return i.ToKmsSignMapOutputWithContext(context.Background())
}

func (i KmsSignMap) ToKmsSignMapOutputWithContext(ctx context.Context) KmsSignMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KmsSignMapOutput)
}

type KmsSignOutput struct {
	*pulumi.OutputState
}

func (KmsSignOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KmsSign)(nil))
}

func (o KmsSignOutput) ToKmsSignOutput() KmsSignOutput {
	return o
}

func (o KmsSignOutput) ToKmsSignOutputWithContext(ctx context.Context) KmsSignOutput {
	return o
}

func (o KmsSignOutput) ToKmsSignPtrOutput() KmsSignPtrOutput {
	return o.ToKmsSignPtrOutputWithContext(context.Background())
}

func (o KmsSignOutput) ToKmsSignPtrOutputWithContext(ctx context.Context) KmsSignPtrOutput {
	return o.ApplyT(func(v KmsSign) *KmsSign {
		return &v
	}).(KmsSignPtrOutput)
}

type KmsSignPtrOutput struct {
	*pulumi.OutputState
}

func (KmsSignPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KmsSign)(nil))
}

func (o KmsSignPtrOutput) ToKmsSignPtrOutput() KmsSignPtrOutput {
	return o
}

func (o KmsSignPtrOutput) ToKmsSignPtrOutputWithContext(ctx context.Context) KmsSignPtrOutput {
	return o
}

type KmsSignArrayOutput struct{ *pulumi.OutputState }

func (KmsSignArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]KmsSign)(nil))
}

func (o KmsSignArrayOutput) ToKmsSignArrayOutput() KmsSignArrayOutput {
	return o
}

func (o KmsSignArrayOutput) ToKmsSignArrayOutputWithContext(ctx context.Context) KmsSignArrayOutput {
	return o
}

func (o KmsSignArrayOutput) Index(i pulumi.IntInput) KmsSignOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) KmsSign {
		return vs[0].([]KmsSign)[vs[1].(int)]
	}).(KmsSignOutput)
}

type KmsSignMapOutput struct{ *pulumi.OutputState }

func (KmsSignMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]KmsSign)(nil))
}

func (o KmsSignMapOutput) ToKmsSignMapOutput() KmsSignMapOutput {
	return o
}

func (o KmsSignMapOutput) ToKmsSignMapOutputWithContext(ctx context.Context) KmsSignMapOutput {
	return o
}

func (o KmsSignMapOutput) MapIndex(k pulumi.StringInput) KmsSignOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) KmsSign {
		return vs[0].(map[string]KmsSign)[vs[1].(string)]
	}).(KmsSignOutput)
}

func init() {
	pulumi.RegisterOutputType(KmsSignOutput{})
	pulumi.RegisterOutputType(KmsSignPtrOutput{})
	pulumi.RegisterOutputType(KmsSignArrayOutput{})
	pulumi.RegisterOutputType(KmsSignMapOutput{})
}
