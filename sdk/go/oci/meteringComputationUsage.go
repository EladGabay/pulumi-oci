// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package oci

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// This resource provides the Usage resource in Oracle Cloud Infrastructure Metering Computation service.
//
// Returns usage for the given account.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-oci/sdk/go/oci"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		_, err := oci.NewMeteringComputationUsage(ctx, "testUsage", &oci.MeteringComputationUsageArgs{
// 			Granularity:      pulumi.Any(_var.Usage_granularity),
// 			TenantId:         pulumi.Any(oci_metering_computation_tenant.Test_tenant.Id),
// 			TimeUsageEnded:   pulumi.Any(_var.Usage_time_usage_ended),
// 			TimeUsageStarted: pulumi.Any(_var.Usage_time_usage_started),
// 			CompartmentDepth: pulumi.Any(_var.Usage_compartment_depth),
// 			Filter:           pulumi.Any(_var.Usage_filter),
// 			Forecast: &MeteringComputationUsageForecastArgs{
// 				TimeForecastEnded:   pulumi.Any(_var.Usage_forecast_time_forecast_ended),
// 				ForecastType:        pulumi.Any(_var.Usage_forecast_forecast_type),
// 				TimeForecastStarted: pulumi.Any(_var.Usage_forecast_time_forecast_started),
// 			},
// 			GroupBies: pulumi.Any(_var.Usage_group_by),
// 			GroupByTags: MeteringComputationUsageGroupByTagArray{
// 				&MeteringComputationUsageGroupByTagArgs{
// 					Key:       pulumi.Any(_var.Usage_group_by_tag_key),
// 					Namespace: pulumi.Any(_var.Usage_group_by_tag_namespace),
// 					Value:     pulumi.Any(_var.Usage_group_by_tag_value),
// 				},
// 			},
// 			IsAggregateByTime: pulumi.Any(_var.Usage_is_aggregate_by_time),
// 			QueryType:         pulumi.Any(_var.Usage_query_type),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
//
// ## Import
//
// Import is not supported for this resource.
type MeteringComputationUsage struct {
	pulumi.CustomResourceState

	// The compartment depth level.
	CompartmentDepth pulumi.Float64Output   `pulumi:"compartmentDepth"`
	Filter           pulumi.StringPtrOutput `pulumi:"filter"`
	// Forecast configuration of usage/cost.
	Forecast MeteringComputationUsageForecastOutput `pulumi:"forecast"`
	// The usage granularity. HOURLY - Hourly data aggregation. DAILY - Daily data aggregation. MONTHLY - Monthly data aggregation. TOTAL - Not yet supported.
	Granularity pulumi.StringOutput `pulumi:"granularity"`
	// Aggregate the result by. example: `["tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName"]`
	GroupBies pulumi.StringArrayOutput `pulumi:"groupBies"`
	// GroupBy a specific tagKey. Provide the tagNamespace and tagKey in the tag object. Only supports one tag in the list. For example: `[{"namespace":"oracle", "key":"createdBy"]`
	GroupByTags MeteringComputationUsageGroupByTagArrayOutput `pulumi:"groupByTags"`
	// Whether aggregated by time. If isAggregateByTime is true, all usage/cost over the query time period will be added up.
	IsAggregateByTime pulumi.BoolOutput `pulumi:"isAggregateByTime"`
	// A list of usage items.
	Items MeteringComputationUsageItemArrayOutput `pulumi:"items"`
	// The query usage type. COST by default if it is missing. Usage - Query the usage data. Cost - Query the cost/billing data. Credit - Query the credit adjustments data. ExpiredCredit - Query the expired credits data. AllCredit - Query the credit adjustments and expired credit.
	QueryType pulumi.StringOutput `pulumi:"queryType"`
	// Tenant ID.
	TenantId pulumi.StringOutput `pulumi:"tenantId"`
	// The usage end time.
	TimeUsageEnded pulumi.StringOutput `pulumi:"timeUsageEnded"`
	// The usage start time.
	TimeUsageStarted pulumi.StringOutput `pulumi:"timeUsageStarted"`
}

// NewMeteringComputationUsage registers a new resource with the given unique name, arguments, and options.
func NewMeteringComputationUsage(ctx *pulumi.Context,
	name string, args *MeteringComputationUsageArgs, opts ...pulumi.ResourceOption) (*MeteringComputationUsage, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Granularity == nil {
		return nil, errors.New("invalid value for required argument 'Granularity'")
	}
	if args.TenantId == nil {
		return nil, errors.New("invalid value for required argument 'TenantId'")
	}
	if args.TimeUsageEnded == nil {
		return nil, errors.New("invalid value for required argument 'TimeUsageEnded'")
	}
	if args.TimeUsageStarted == nil {
		return nil, errors.New("invalid value for required argument 'TimeUsageStarted'")
	}
	var resource MeteringComputationUsage
	err := ctx.RegisterResource("oci:index/meteringComputationUsage:MeteringComputationUsage", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetMeteringComputationUsage gets an existing MeteringComputationUsage resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetMeteringComputationUsage(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *MeteringComputationUsageState, opts ...pulumi.ResourceOption) (*MeteringComputationUsage, error) {
	var resource MeteringComputationUsage
	err := ctx.ReadResource("oci:index/meteringComputationUsage:MeteringComputationUsage", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering MeteringComputationUsage resources.
type meteringComputationUsageState struct {
	// The compartment depth level.
	CompartmentDepth *float64 `pulumi:"compartmentDepth"`
	Filter           *string  `pulumi:"filter"`
	// Forecast configuration of usage/cost.
	Forecast *MeteringComputationUsageForecast `pulumi:"forecast"`
	// The usage granularity. HOURLY - Hourly data aggregation. DAILY - Daily data aggregation. MONTHLY - Monthly data aggregation. TOTAL - Not yet supported.
	Granularity *string `pulumi:"granularity"`
	// Aggregate the result by. example: `["tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName"]`
	GroupBies []string `pulumi:"groupBies"`
	// GroupBy a specific tagKey. Provide the tagNamespace and tagKey in the tag object. Only supports one tag in the list. For example: `[{"namespace":"oracle", "key":"createdBy"]`
	GroupByTags []MeteringComputationUsageGroupByTag `pulumi:"groupByTags"`
	// Whether aggregated by time. If isAggregateByTime is true, all usage/cost over the query time period will be added up.
	IsAggregateByTime *bool `pulumi:"isAggregateByTime"`
	// A list of usage items.
	Items []MeteringComputationUsageItem `pulumi:"items"`
	// The query usage type. COST by default if it is missing. Usage - Query the usage data. Cost - Query the cost/billing data. Credit - Query the credit adjustments data. ExpiredCredit - Query the expired credits data. AllCredit - Query the credit adjustments and expired credit.
	QueryType *string `pulumi:"queryType"`
	// Tenant ID.
	TenantId *string `pulumi:"tenantId"`
	// The usage end time.
	TimeUsageEnded *string `pulumi:"timeUsageEnded"`
	// The usage start time.
	TimeUsageStarted *string `pulumi:"timeUsageStarted"`
}

type MeteringComputationUsageState struct {
	// The compartment depth level.
	CompartmentDepth pulumi.Float64PtrInput
	Filter           pulumi.StringPtrInput
	// Forecast configuration of usage/cost.
	Forecast MeteringComputationUsageForecastPtrInput
	// The usage granularity. HOURLY - Hourly data aggregation. DAILY - Daily data aggregation. MONTHLY - Monthly data aggregation. TOTAL - Not yet supported.
	Granularity pulumi.StringPtrInput
	// Aggregate the result by. example: `["tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName"]`
	GroupBies pulumi.StringArrayInput
	// GroupBy a specific tagKey. Provide the tagNamespace and tagKey in the tag object. Only supports one tag in the list. For example: `[{"namespace":"oracle", "key":"createdBy"]`
	GroupByTags MeteringComputationUsageGroupByTagArrayInput
	// Whether aggregated by time. If isAggregateByTime is true, all usage/cost over the query time period will be added up.
	IsAggregateByTime pulumi.BoolPtrInput
	// A list of usage items.
	Items MeteringComputationUsageItemArrayInput
	// The query usage type. COST by default if it is missing. Usage - Query the usage data. Cost - Query the cost/billing data. Credit - Query the credit adjustments data. ExpiredCredit - Query the expired credits data. AllCredit - Query the credit adjustments and expired credit.
	QueryType pulumi.StringPtrInput
	// Tenant ID.
	TenantId pulumi.StringPtrInput
	// The usage end time.
	TimeUsageEnded pulumi.StringPtrInput
	// The usage start time.
	TimeUsageStarted pulumi.StringPtrInput
}

func (MeteringComputationUsageState) ElementType() reflect.Type {
	return reflect.TypeOf((*meteringComputationUsageState)(nil)).Elem()
}

type meteringComputationUsageArgs struct {
	// The compartment depth level.
	CompartmentDepth *float64 `pulumi:"compartmentDepth"`
	Filter           *string  `pulumi:"filter"`
	// Forecast configuration of usage/cost.
	Forecast *MeteringComputationUsageForecast `pulumi:"forecast"`
	// The usage granularity. HOURLY - Hourly data aggregation. DAILY - Daily data aggregation. MONTHLY - Monthly data aggregation. TOTAL - Not yet supported.
	Granularity string `pulumi:"granularity"`
	// Aggregate the result by. example: `["tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName"]`
	GroupBies []string `pulumi:"groupBies"`
	// GroupBy a specific tagKey. Provide the tagNamespace and tagKey in the tag object. Only supports one tag in the list. For example: `[{"namespace":"oracle", "key":"createdBy"]`
	GroupByTags []MeteringComputationUsageGroupByTag `pulumi:"groupByTags"`
	// Whether aggregated by time. If isAggregateByTime is true, all usage/cost over the query time period will be added up.
	IsAggregateByTime *bool `pulumi:"isAggregateByTime"`
	// The query usage type. COST by default if it is missing. Usage - Query the usage data. Cost - Query the cost/billing data. Credit - Query the credit adjustments data. ExpiredCredit - Query the expired credits data. AllCredit - Query the credit adjustments and expired credit.
	QueryType *string `pulumi:"queryType"`
	// Tenant ID.
	TenantId string `pulumi:"tenantId"`
	// The usage end time.
	TimeUsageEnded string `pulumi:"timeUsageEnded"`
	// The usage start time.
	TimeUsageStarted string `pulumi:"timeUsageStarted"`
}

// The set of arguments for constructing a MeteringComputationUsage resource.
type MeteringComputationUsageArgs struct {
	// The compartment depth level.
	CompartmentDepth pulumi.Float64PtrInput
	Filter           pulumi.StringPtrInput
	// Forecast configuration of usage/cost.
	Forecast MeteringComputationUsageForecastPtrInput
	// The usage granularity. HOURLY - Hourly data aggregation. DAILY - Daily data aggregation. MONTHLY - Monthly data aggregation. TOTAL - Not yet supported.
	Granularity pulumi.StringInput
	// Aggregate the result by. example: `["tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName"]`
	GroupBies pulumi.StringArrayInput
	// GroupBy a specific tagKey. Provide the tagNamespace and tagKey in the tag object. Only supports one tag in the list. For example: `[{"namespace":"oracle", "key":"createdBy"]`
	GroupByTags MeteringComputationUsageGroupByTagArrayInput
	// Whether aggregated by time. If isAggregateByTime is true, all usage/cost over the query time period will be added up.
	IsAggregateByTime pulumi.BoolPtrInput
	// The query usage type. COST by default if it is missing. Usage - Query the usage data. Cost - Query the cost/billing data. Credit - Query the credit adjustments data. ExpiredCredit - Query the expired credits data. AllCredit - Query the credit adjustments and expired credit.
	QueryType pulumi.StringPtrInput
	// Tenant ID.
	TenantId pulumi.StringInput
	// The usage end time.
	TimeUsageEnded pulumi.StringInput
	// The usage start time.
	TimeUsageStarted pulumi.StringInput
}

func (MeteringComputationUsageArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*meteringComputationUsageArgs)(nil)).Elem()
}

type MeteringComputationUsageInput interface {
	pulumi.Input

	ToMeteringComputationUsageOutput() MeteringComputationUsageOutput
	ToMeteringComputationUsageOutputWithContext(ctx context.Context) MeteringComputationUsageOutput
}

func (*MeteringComputationUsage) ElementType() reflect.Type {
	return reflect.TypeOf((*MeteringComputationUsage)(nil))
}

func (i *MeteringComputationUsage) ToMeteringComputationUsageOutput() MeteringComputationUsageOutput {
	return i.ToMeteringComputationUsageOutputWithContext(context.Background())
}

func (i *MeteringComputationUsage) ToMeteringComputationUsageOutputWithContext(ctx context.Context) MeteringComputationUsageOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MeteringComputationUsageOutput)
}

func (i *MeteringComputationUsage) ToMeteringComputationUsagePtrOutput() MeteringComputationUsagePtrOutput {
	return i.ToMeteringComputationUsagePtrOutputWithContext(context.Background())
}

func (i *MeteringComputationUsage) ToMeteringComputationUsagePtrOutputWithContext(ctx context.Context) MeteringComputationUsagePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MeteringComputationUsagePtrOutput)
}

type MeteringComputationUsagePtrInput interface {
	pulumi.Input

	ToMeteringComputationUsagePtrOutput() MeteringComputationUsagePtrOutput
	ToMeteringComputationUsagePtrOutputWithContext(ctx context.Context) MeteringComputationUsagePtrOutput
}

type meteringComputationUsagePtrType MeteringComputationUsageArgs

func (*meteringComputationUsagePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**MeteringComputationUsage)(nil))
}

func (i *meteringComputationUsagePtrType) ToMeteringComputationUsagePtrOutput() MeteringComputationUsagePtrOutput {
	return i.ToMeteringComputationUsagePtrOutputWithContext(context.Background())
}

func (i *meteringComputationUsagePtrType) ToMeteringComputationUsagePtrOutputWithContext(ctx context.Context) MeteringComputationUsagePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MeteringComputationUsagePtrOutput)
}

// MeteringComputationUsageArrayInput is an input type that accepts MeteringComputationUsageArray and MeteringComputationUsageArrayOutput values.
// You can construct a concrete instance of `MeteringComputationUsageArrayInput` via:
//
//          MeteringComputationUsageArray{ MeteringComputationUsageArgs{...} }
type MeteringComputationUsageArrayInput interface {
	pulumi.Input

	ToMeteringComputationUsageArrayOutput() MeteringComputationUsageArrayOutput
	ToMeteringComputationUsageArrayOutputWithContext(context.Context) MeteringComputationUsageArrayOutput
}

type MeteringComputationUsageArray []MeteringComputationUsageInput

func (MeteringComputationUsageArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*MeteringComputationUsage)(nil)).Elem()
}

func (i MeteringComputationUsageArray) ToMeteringComputationUsageArrayOutput() MeteringComputationUsageArrayOutput {
	return i.ToMeteringComputationUsageArrayOutputWithContext(context.Background())
}

func (i MeteringComputationUsageArray) ToMeteringComputationUsageArrayOutputWithContext(ctx context.Context) MeteringComputationUsageArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MeteringComputationUsageArrayOutput)
}

// MeteringComputationUsageMapInput is an input type that accepts MeteringComputationUsageMap and MeteringComputationUsageMapOutput values.
// You can construct a concrete instance of `MeteringComputationUsageMapInput` via:
//
//          MeteringComputationUsageMap{ "key": MeteringComputationUsageArgs{...} }
type MeteringComputationUsageMapInput interface {
	pulumi.Input

	ToMeteringComputationUsageMapOutput() MeteringComputationUsageMapOutput
	ToMeteringComputationUsageMapOutputWithContext(context.Context) MeteringComputationUsageMapOutput
}

type MeteringComputationUsageMap map[string]MeteringComputationUsageInput

func (MeteringComputationUsageMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*MeteringComputationUsage)(nil)).Elem()
}

func (i MeteringComputationUsageMap) ToMeteringComputationUsageMapOutput() MeteringComputationUsageMapOutput {
	return i.ToMeteringComputationUsageMapOutputWithContext(context.Background())
}

func (i MeteringComputationUsageMap) ToMeteringComputationUsageMapOutputWithContext(ctx context.Context) MeteringComputationUsageMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MeteringComputationUsageMapOutput)
}

type MeteringComputationUsageOutput struct {
	*pulumi.OutputState
}

func (MeteringComputationUsageOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MeteringComputationUsage)(nil))
}

func (o MeteringComputationUsageOutput) ToMeteringComputationUsageOutput() MeteringComputationUsageOutput {
	return o
}

func (o MeteringComputationUsageOutput) ToMeteringComputationUsageOutputWithContext(ctx context.Context) MeteringComputationUsageOutput {
	return o
}

func (o MeteringComputationUsageOutput) ToMeteringComputationUsagePtrOutput() MeteringComputationUsagePtrOutput {
	return o.ToMeteringComputationUsagePtrOutputWithContext(context.Background())
}

func (o MeteringComputationUsageOutput) ToMeteringComputationUsagePtrOutputWithContext(ctx context.Context) MeteringComputationUsagePtrOutput {
	return o.ApplyT(func(v MeteringComputationUsage) *MeteringComputationUsage {
		return &v
	}).(MeteringComputationUsagePtrOutput)
}

type MeteringComputationUsagePtrOutput struct {
	*pulumi.OutputState
}

func (MeteringComputationUsagePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MeteringComputationUsage)(nil))
}

func (o MeteringComputationUsagePtrOutput) ToMeteringComputationUsagePtrOutput() MeteringComputationUsagePtrOutput {
	return o
}

func (o MeteringComputationUsagePtrOutput) ToMeteringComputationUsagePtrOutputWithContext(ctx context.Context) MeteringComputationUsagePtrOutput {
	return o
}

type MeteringComputationUsageArrayOutput struct{ *pulumi.OutputState }

func (MeteringComputationUsageArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]MeteringComputationUsage)(nil))
}

func (o MeteringComputationUsageArrayOutput) ToMeteringComputationUsageArrayOutput() MeteringComputationUsageArrayOutput {
	return o
}

func (o MeteringComputationUsageArrayOutput) ToMeteringComputationUsageArrayOutputWithContext(ctx context.Context) MeteringComputationUsageArrayOutput {
	return o
}

func (o MeteringComputationUsageArrayOutput) Index(i pulumi.IntInput) MeteringComputationUsageOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) MeteringComputationUsage {
		return vs[0].([]MeteringComputationUsage)[vs[1].(int)]
	}).(MeteringComputationUsageOutput)
}

type MeteringComputationUsageMapOutput struct{ *pulumi.OutputState }

func (MeteringComputationUsageMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]MeteringComputationUsage)(nil))
}

func (o MeteringComputationUsageMapOutput) ToMeteringComputationUsageMapOutput() MeteringComputationUsageMapOutput {
	return o
}

func (o MeteringComputationUsageMapOutput) ToMeteringComputationUsageMapOutputWithContext(ctx context.Context) MeteringComputationUsageMapOutput {
	return o
}

func (o MeteringComputationUsageMapOutput) MapIndex(k pulumi.StringInput) MeteringComputationUsageOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) MeteringComputationUsage {
		return vs[0].(map[string]MeteringComputationUsage)[vs[1].(string)]
	}).(MeteringComputationUsageOutput)
}

func init() {
	pulumi.RegisterOutputType(MeteringComputationUsageOutput{})
	pulumi.RegisterOutputType(MeteringComputationUsagePtrOutput{})
	pulumi.RegisterOutputType(MeteringComputationUsageArrayOutput{})
	pulumi.RegisterOutputType(MeteringComputationUsageMapOutput{})
}
