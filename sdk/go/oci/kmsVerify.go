// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package oci

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// This resource provides the Verify resource in Oracle Cloud Infrastructure Kms service.
//
// Verifies a digital signature that was generated by the [Sign](https://docs.cloud.oracle.com/iaas/api/#/en/key/latest/SignedData/Sign) operation
// by using the public key of the same asymmetric key that was used to sign the data. If you want to validate the\
// digital signature outside of the service, you can do so by using the public key of the asymmetric key.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-oci/sdk/go/oci"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		_, err := oci.NewKmsVerify(ctx, "testVerify", &oci.KmsVerifyArgs{
// 			CryptoEndpoint:   pulumi.Any(_var.Verify_message_crypto_endpoint),
// 			KeyId:            pulumi.Any(oci_kms_key.Test_key.Id),
// 			KeyVersionId:     pulumi.Any(oci_kms_key_version.Test_key_version.Id),
// 			Message:          pulumi.Any(_var.Verify_message),
// 			Signature:        pulumi.Any(_var.Verify_signature),
// 			SigningAlgorithm: pulumi.Any(_var.Verify_signing_algorithm),
// 			MessageType:      pulumi.Any(_var.Verify_message_type),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
//
// ## Import
//
// Verify can be imported using the `id`, e.g.
//
// ```sh
//  $ pulumi import oci:index/kmsVerify:KmsVerify test_verify "id"
// ```
type KmsVerify struct {
	pulumi.CustomResourceState

	// The service endpoint to perform cryptographic operations against. Cryptographic operations include 'Encrypt,' 'Decrypt,', 'GenerateDataEncryptionKey', 'Sign' and 'Verify' operations. see Vault Crypto endpoint.
	CryptoEndpoint pulumi.StringOutput `pulumi:"cryptoEndpoint"`
	// A Boolean value that indicates whether the signature was verified.
	IsSignatureValid pulumi.BoolOutput `pulumi:"isSignatureValid"`
	// The OCID of the key used to sign the message.
	KeyId pulumi.StringOutput `pulumi:"keyId"`
	// The OCID of the key version used to sign the message.
	KeyVersionId pulumi.StringOutput `pulumi:"keyVersionId"`
	// The base64-encoded binary data object denoting the message or message digest to sign. You can have a message up to 4096 bytes in size. To sign a larger message, provide the message digest.
	Message pulumi.StringOutput `pulumi:"message"`
	// Denotes whether the value of the message parameter is a raw message or a message digest.  The default value, `RAW`, indicates a message. To indicate a message digest, use `DIGEST`.
	MessageType pulumi.StringOutput `pulumi:"messageType"`
	// The base64-encoded binary data object denoting the cryptographic signature generated for the message.
	Signature pulumi.StringOutput `pulumi:"signature"`
	// The algorithm to use to sign the message or message digest. For RSA keys, supported signature schemes include PKCS #1 and RSASSA-PSS, along with  different hashing algorithms.  For ECDSA keys, ECDSA is the supported signature scheme with different hashing algorithms. When you pass a message digest for signing, ensure that you specify the same hashing algorithm  as used when creating the message digest.
	SigningAlgorithm pulumi.StringOutput `pulumi:"signingAlgorithm"`
}

// NewKmsVerify registers a new resource with the given unique name, arguments, and options.
func NewKmsVerify(ctx *pulumi.Context,
	name string, args *KmsVerifyArgs, opts ...pulumi.ResourceOption) (*KmsVerify, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.CryptoEndpoint == nil {
		return nil, errors.New("invalid value for required argument 'CryptoEndpoint'")
	}
	if args.KeyId == nil {
		return nil, errors.New("invalid value for required argument 'KeyId'")
	}
	if args.KeyVersionId == nil {
		return nil, errors.New("invalid value for required argument 'KeyVersionId'")
	}
	if args.Message == nil {
		return nil, errors.New("invalid value for required argument 'Message'")
	}
	if args.Signature == nil {
		return nil, errors.New("invalid value for required argument 'Signature'")
	}
	if args.SigningAlgorithm == nil {
		return nil, errors.New("invalid value for required argument 'SigningAlgorithm'")
	}
	var resource KmsVerify
	err := ctx.RegisterResource("oci:index/kmsVerify:KmsVerify", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetKmsVerify gets an existing KmsVerify resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetKmsVerify(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *KmsVerifyState, opts ...pulumi.ResourceOption) (*KmsVerify, error) {
	var resource KmsVerify
	err := ctx.ReadResource("oci:index/kmsVerify:KmsVerify", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering KmsVerify resources.
type kmsVerifyState struct {
	// The service endpoint to perform cryptographic operations against. Cryptographic operations include 'Encrypt,' 'Decrypt,', 'GenerateDataEncryptionKey', 'Sign' and 'Verify' operations. see Vault Crypto endpoint.
	CryptoEndpoint *string `pulumi:"cryptoEndpoint"`
	// A Boolean value that indicates whether the signature was verified.
	IsSignatureValid *bool `pulumi:"isSignatureValid"`
	// The OCID of the key used to sign the message.
	KeyId *string `pulumi:"keyId"`
	// The OCID of the key version used to sign the message.
	KeyVersionId *string `pulumi:"keyVersionId"`
	// The base64-encoded binary data object denoting the message or message digest to sign. You can have a message up to 4096 bytes in size. To sign a larger message, provide the message digest.
	Message *string `pulumi:"message"`
	// Denotes whether the value of the message parameter is a raw message or a message digest.  The default value, `RAW`, indicates a message. To indicate a message digest, use `DIGEST`.
	MessageType *string `pulumi:"messageType"`
	// The base64-encoded binary data object denoting the cryptographic signature generated for the message.
	Signature *string `pulumi:"signature"`
	// The algorithm to use to sign the message or message digest. For RSA keys, supported signature schemes include PKCS #1 and RSASSA-PSS, along with  different hashing algorithms.  For ECDSA keys, ECDSA is the supported signature scheme with different hashing algorithms. When you pass a message digest for signing, ensure that you specify the same hashing algorithm  as used when creating the message digest.
	SigningAlgorithm *string `pulumi:"signingAlgorithm"`
}

type KmsVerifyState struct {
	// The service endpoint to perform cryptographic operations against. Cryptographic operations include 'Encrypt,' 'Decrypt,', 'GenerateDataEncryptionKey', 'Sign' and 'Verify' operations. see Vault Crypto endpoint.
	CryptoEndpoint pulumi.StringPtrInput
	// A Boolean value that indicates whether the signature was verified.
	IsSignatureValid pulumi.BoolPtrInput
	// The OCID of the key used to sign the message.
	KeyId pulumi.StringPtrInput
	// The OCID of the key version used to sign the message.
	KeyVersionId pulumi.StringPtrInput
	// The base64-encoded binary data object denoting the message or message digest to sign. You can have a message up to 4096 bytes in size. To sign a larger message, provide the message digest.
	Message pulumi.StringPtrInput
	// Denotes whether the value of the message parameter is a raw message or a message digest.  The default value, `RAW`, indicates a message. To indicate a message digest, use `DIGEST`.
	MessageType pulumi.StringPtrInput
	// The base64-encoded binary data object denoting the cryptographic signature generated for the message.
	Signature pulumi.StringPtrInput
	// The algorithm to use to sign the message or message digest. For RSA keys, supported signature schemes include PKCS #1 and RSASSA-PSS, along with  different hashing algorithms.  For ECDSA keys, ECDSA is the supported signature scheme with different hashing algorithms. When you pass a message digest for signing, ensure that you specify the same hashing algorithm  as used when creating the message digest.
	SigningAlgorithm pulumi.StringPtrInput
}

func (KmsVerifyState) ElementType() reflect.Type {
	return reflect.TypeOf((*kmsVerifyState)(nil)).Elem()
}

type kmsVerifyArgs struct {
	// The service endpoint to perform cryptographic operations against. Cryptographic operations include 'Encrypt,' 'Decrypt,', 'GenerateDataEncryptionKey', 'Sign' and 'Verify' operations. see Vault Crypto endpoint.
	CryptoEndpoint string `pulumi:"cryptoEndpoint"`
	// The OCID of the key used to sign the message.
	KeyId string `pulumi:"keyId"`
	// The OCID of the key version used to sign the message.
	KeyVersionId string `pulumi:"keyVersionId"`
	// The base64-encoded binary data object denoting the message or message digest to sign. You can have a message up to 4096 bytes in size. To sign a larger message, provide the message digest.
	Message string `pulumi:"message"`
	// Denotes whether the value of the message parameter is a raw message or a message digest.  The default value, `RAW`, indicates a message. To indicate a message digest, use `DIGEST`.
	MessageType *string `pulumi:"messageType"`
	// The base64-encoded binary data object denoting the cryptographic signature generated for the message.
	Signature string `pulumi:"signature"`
	// The algorithm to use to sign the message or message digest. For RSA keys, supported signature schemes include PKCS #1 and RSASSA-PSS, along with  different hashing algorithms.  For ECDSA keys, ECDSA is the supported signature scheme with different hashing algorithms. When you pass a message digest for signing, ensure that you specify the same hashing algorithm  as used when creating the message digest.
	SigningAlgorithm string `pulumi:"signingAlgorithm"`
}

// The set of arguments for constructing a KmsVerify resource.
type KmsVerifyArgs struct {
	// The service endpoint to perform cryptographic operations against. Cryptographic operations include 'Encrypt,' 'Decrypt,', 'GenerateDataEncryptionKey', 'Sign' and 'Verify' operations. see Vault Crypto endpoint.
	CryptoEndpoint pulumi.StringInput
	// The OCID of the key used to sign the message.
	KeyId pulumi.StringInput
	// The OCID of the key version used to sign the message.
	KeyVersionId pulumi.StringInput
	// The base64-encoded binary data object denoting the message or message digest to sign. You can have a message up to 4096 bytes in size. To sign a larger message, provide the message digest.
	Message pulumi.StringInput
	// Denotes whether the value of the message parameter is a raw message or a message digest.  The default value, `RAW`, indicates a message. To indicate a message digest, use `DIGEST`.
	MessageType pulumi.StringPtrInput
	// The base64-encoded binary data object denoting the cryptographic signature generated for the message.
	Signature pulumi.StringInput
	// The algorithm to use to sign the message or message digest. For RSA keys, supported signature schemes include PKCS #1 and RSASSA-PSS, along with  different hashing algorithms.  For ECDSA keys, ECDSA is the supported signature scheme with different hashing algorithms. When you pass a message digest for signing, ensure that you specify the same hashing algorithm  as used when creating the message digest.
	SigningAlgorithm pulumi.StringInput
}

func (KmsVerifyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*kmsVerifyArgs)(nil)).Elem()
}

type KmsVerifyInput interface {
	pulumi.Input

	ToKmsVerifyOutput() KmsVerifyOutput
	ToKmsVerifyOutputWithContext(ctx context.Context) KmsVerifyOutput
}

func (*KmsVerify) ElementType() reflect.Type {
	return reflect.TypeOf((*KmsVerify)(nil))
}

func (i *KmsVerify) ToKmsVerifyOutput() KmsVerifyOutput {
	return i.ToKmsVerifyOutputWithContext(context.Background())
}

func (i *KmsVerify) ToKmsVerifyOutputWithContext(ctx context.Context) KmsVerifyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KmsVerifyOutput)
}

func (i *KmsVerify) ToKmsVerifyPtrOutput() KmsVerifyPtrOutput {
	return i.ToKmsVerifyPtrOutputWithContext(context.Background())
}

func (i *KmsVerify) ToKmsVerifyPtrOutputWithContext(ctx context.Context) KmsVerifyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KmsVerifyPtrOutput)
}

type KmsVerifyPtrInput interface {
	pulumi.Input

	ToKmsVerifyPtrOutput() KmsVerifyPtrOutput
	ToKmsVerifyPtrOutputWithContext(ctx context.Context) KmsVerifyPtrOutput
}

type kmsVerifyPtrType KmsVerifyArgs

func (*kmsVerifyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**KmsVerify)(nil))
}

func (i *kmsVerifyPtrType) ToKmsVerifyPtrOutput() KmsVerifyPtrOutput {
	return i.ToKmsVerifyPtrOutputWithContext(context.Background())
}

func (i *kmsVerifyPtrType) ToKmsVerifyPtrOutputWithContext(ctx context.Context) KmsVerifyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KmsVerifyPtrOutput)
}

// KmsVerifyArrayInput is an input type that accepts KmsVerifyArray and KmsVerifyArrayOutput values.
// You can construct a concrete instance of `KmsVerifyArrayInput` via:
//
//          KmsVerifyArray{ KmsVerifyArgs{...} }
type KmsVerifyArrayInput interface {
	pulumi.Input

	ToKmsVerifyArrayOutput() KmsVerifyArrayOutput
	ToKmsVerifyArrayOutputWithContext(context.Context) KmsVerifyArrayOutput
}

type KmsVerifyArray []KmsVerifyInput

func (KmsVerifyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*KmsVerify)(nil)).Elem()
}

func (i KmsVerifyArray) ToKmsVerifyArrayOutput() KmsVerifyArrayOutput {
	return i.ToKmsVerifyArrayOutputWithContext(context.Background())
}

func (i KmsVerifyArray) ToKmsVerifyArrayOutputWithContext(ctx context.Context) KmsVerifyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KmsVerifyArrayOutput)
}

// KmsVerifyMapInput is an input type that accepts KmsVerifyMap and KmsVerifyMapOutput values.
// You can construct a concrete instance of `KmsVerifyMapInput` via:
//
//          KmsVerifyMap{ "key": KmsVerifyArgs{...} }
type KmsVerifyMapInput interface {
	pulumi.Input

	ToKmsVerifyMapOutput() KmsVerifyMapOutput
	ToKmsVerifyMapOutputWithContext(context.Context) KmsVerifyMapOutput
}

type KmsVerifyMap map[string]KmsVerifyInput

func (KmsVerifyMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*KmsVerify)(nil)).Elem()
}

func (i KmsVerifyMap) ToKmsVerifyMapOutput() KmsVerifyMapOutput {
	return i.ToKmsVerifyMapOutputWithContext(context.Background())
}

func (i KmsVerifyMap) ToKmsVerifyMapOutputWithContext(ctx context.Context) KmsVerifyMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KmsVerifyMapOutput)
}

type KmsVerifyOutput struct {
	*pulumi.OutputState
}

func (KmsVerifyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KmsVerify)(nil))
}

func (o KmsVerifyOutput) ToKmsVerifyOutput() KmsVerifyOutput {
	return o
}

func (o KmsVerifyOutput) ToKmsVerifyOutputWithContext(ctx context.Context) KmsVerifyOutput {
	return o
}

func (o KmsVerifyOutput) ToKmsVerifyPtrOutput() KmsVerifyPtrOutput {
	return o.ToKmsVerifyPtrOutputWithContext(context.Background())
}

func (o KmsVerifyOutput) ToKmsVerifyPtrOutputWithContext(ctx context.Context) KmsVerifyPtrOutput {
	return o.ApplyT(func(v KmsVerify) *KmsVerify {
		return &v
	}).(KmsVerifyPtrOutput)
}

type KmsVerifyPtrOutput struct {
	*pulumi.OutputState
}

func (KmsVerifyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KmsVerify)(nil))
}

func (o KmsVerifyPtrOutput) ToKmsVerifyPtrOutput() KmsVerifyPtrOutput {
	return o
}

func (o KmsVerifyPtrOutput) ToKmsVerifyPtrOutputWithContext(ctx context.Context) KmsVerifyPtrOutput {
	return o
}

type KmsVerifyArrayOutput struct{ *pulumi.OutputState }

func (KmsVerifyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]KmsVerify)(nil))
}

func (o KmsVerifyArrayOutput) ToKmsVerifyArrayOutput() KmsVerifyArrayOutput {
	return o
}

func (o KmsVerifyArrayOutput) ToKmsVerifyArrayOutputWithContext(ctx context.Context) KmsVerifyArrayOutput {
	return o
}

func (o KmsVerifyArrayOutput) Index(i pulumi.IntInput) KmsVerifyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) KmsVerify {
		return vs[0].([]KmsVerify)[vs[1].(int)]
	}).(KmsVerifyOutput)
}

type KmsVerifyMapOutput struct{ *pulumi.OutputState }

func (KmsVerifyMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]KmsVerify)(nil))
}

func (o KmsVerifyMapOutput) ToKmsVerifyMapOutput() KmsVerifyMapOutput {
	return o
}

func (o KmsVerifyMapOutput) ToKmsVerifyMapOutputWithContext(ctx context.Context) KmsVerifyMapOutput {
	return o
}

func (o KmsVerifyMapOutput) MapIndex(k pulumi.StringInput) KmsVerifyOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) KmsVerify {
		return vs[0].(map[string]KmsVerify)[vs[1].(string)]
	}).(KmsVerifyOutput)
}

func init() {
	pulumi.RegisterOutputType(KmsVerifyOutput{})
	pulumi.RegisterOutputType(KmsVerifyPtrOutput{})
	pulumi.RegisterOutputType(KmsVerifyArrayOutput{})
	pulumi.RegisterOutputType(KmsVerifyMapOutput{})
}
